#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 1, rgba8) uniform writeonly image2D outputImage;

layout(std140, binding = 2) buffer SceneBuffer 
{
	vec4 datas[];
} inSceneData;

#define EPSILON 			0.0001
#define MAXLEN 				1000.0
#define SHADOW 				0.5
#define RAYBOUNCES 			10
#define REFLECTIONS 		1
#define REFLECTIONSTRENGTH 	0.4
#define REFLECTIONFALLOFF 	0.5

struct Sphere
{
	vec4  position; // position + radius
	vec4  diffuse;  // diffuse + specular
	ivec4 id;       // id + padding
};

struct Plane
{
	vec4  normal;  // normal + distance
	vec4  diffuse; // diffuse + specular
	ivec4 id;      // id + padding
};

layout (binding = 0) uniform RaytracingParamBlock
{
	Sphere spheres[3];
	Plane  planes[6];

	vec4 lightPos;  // lightPos + padding
	vec4 fogColor;
	vec4 cameraPos; // cameraPos + aspect

	mat4 invProjection;
	mat4 invView;
} uboParam;

// Lighting =========================================================

float LightSpecular(vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(uboParam.cameraPos.xyz);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

vec3 ReflectRay(vec3 ray, vec3 normal)
{
	return ray + 2.0 * -dot(normal, ray) * normal;
}

// ---------------- intersection ----------------
struct HitInfo
{
	vec3 	position;
	float 	t;
	vec3 	normal;
	bool 	inside;
};

bool IntersectTriangle(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2, inout HitInfo hitInfo)
{
	float t, u, v;

	vec3 edge1 = v1 - v0;
	vec3 edge2 = v2 - v0;
	vec3 pvec  = cross(dir, edge2);
	float det  = dot(edge1, pvec);

	vec3 tvec;
	if (det > 0) {
		tvec = orig - v0;
	}
	else {
		tvec = v0 - orig;
		det  = -det;
	}

	if (det < 0.0001) {
		return false;
	}

	u = dot(tvec, pvec);
	if (u < 0.0 || u > det) {
		return false;
	}

	vec3 qvec = cross(tvec,edge1);
	v = dot(dir, qvec);
	if (v < 0.0 || u + v > det) {
		return false;
	}

	t = dot(edge2, qvec);

	float fInvDet = 1.0 / det;
	t *= fInvDet;
	u *= fInvDet;
	v *= fInvDet;

	hitInfo.position = orig + dir * t;
	hitInfo.t        = t;
	hitInfo.normal   = normalize(cross(edge1, edge2));
	hitInfo.inside   = dot(hitInfo.normal, dir) > 0;

	return true;
}

// --------------------------------------------------------------
int HitScene(in vec3 pos, in vec3 ray, inout float dist, inout vec3 hitNormal)
{
	int id  = -1;

	HitInfo hitInfo;

	// first element store object size
	int count  = int(inSceneData.datas[0].x);
	int index  = 1;
	for (int i = 0; i < count; ++i)
	{
		ivec4 head = ivec4(inSceneData.datas[index]);
		int meshID = head.x;
		int geomID = head.y;
		int verNum = head.z;
		int idxNum = head.w;
		// offset to mesh data
		index += 1;
		// indices
		for (int j = 0; j < idxNum; ++j)
		{
			ivec4 idx = ivec4(inSceneData.datas[index + j]);
			vec4 v0 = inSceneData.datas[index + idxNum + idx.x];
			vec4 v1 = inSceneData.datas[index + idxNum + idx.y];
			vec4 v2 = inSceneData.datas[index + idxNum + idx.z];

			// hit test
			if (IntersectTriangle(pos, ray, v0.xyz, v1.xyz, v2.xyz, hitInfo))
			{
				if (hitInfo.t < dist)
				{
					id = meshID;
					dist = hitInfo.t;
					hitNormal = hitInfo.normal;
				}
			}
		}
		// offset to next object
		index += idxNum;
		index += verNum;
	}

	return id;
}

vec4 RenderScene(inout vec3 pos, inout vec3 ray, inout int id)
{
	float dist  = MAXLEN;
	vec4 color  = vec4(0, 0, 0, 0);
	vec3 normal = vec3(0, 0, 0);

	int objectID = HitScene(pos, ray, dist, normal);
	if (objectID == -1) {
		return color;
	}
	
	vec3 position  = pos + dist * ray;
	vec3 lightDir  = normalize(uboParam.lightPos.xyz - position);				
	float diffuse  = clamp(dot(normal, lightDir), 0.0, 1.0);
	color = diffuse * vec4(1, 1, 1, 1);
	
	if (id == -1) {
		return color;
	}

	id  = objectID;
	ray = ReflectRay(ray, normal);
	pos = position;	
	
	return color;
}

void main()
{	
	ivec2 dim = imageSize(outputImage);
	vec2 uv   = vec2(gl_GlobalInvocationID.xy) / dim;

	vec3 pos = uboParam.cameraPos.xyz;
	vec3 ray = vec3(uv.x * 2.0 - 1.0, -(uv.y * 2.0 - 1.0), 1.0);
	
	ray   = (uboParam.invProjection * vec4(ray, 1.0)).xyz;
	ray.x = ray.x * ray.z;
	ray.y = ray.y * ray.z;

	ray.xyz = (uboParam.invView * vec4(ray, 0.0)).xyz;
	ray.xyz = normalize(ray.xyz);
	
	// Basic color path
	int id = 0;
	vec4 finalColor = RenderScene(pos, ray, id);
	
	// Reflection
#if REFLECTIONS
	float reflectionStrength = REFLECTIONSTRENGTH;
	for (int i = 0; i < RAYBOUNCES; ++i)
	{
		vec4 reflectionColor = RenderScene(pos, ray, id);
		finalColor = (1.0 - reflectionStrength) * finalColor + reflectionStrength * mix(reflectionColor, finalColor, 1.0 - reflectionStrength);			
		reflectionStrength *= REFLECTIONFALLOFF;
	}
#endif
	
	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), finalColor);
}